/**
 * Bash completion script generator (dynamic)
 */

import type { AnyCommand } from "../types.js";
import type { CompletionOptions, CompletionResult } from "./types.js";

/**
 * Generate bash completion script for a command
 *
 * Generates a minimal script that delegates all logic to the CLI's __complete command.
 * The shell script only handles:
 * - Getting current command line tokens
 * - Calling __complete with --shell bash
 * - Setting COMPREPLY from the output
 * - Falling back to native file/directory completion when directed
 */
export function generateBashCompletion(
  _command: AnyCommand,
  options: CompletionOptions,
): CompletionResult {
  const programName = options.programName;

  return {
    script: `# Bash completion for ${programName}
# Generated by politty

_${programName}_completions() {
    local IFS=$'\\n'
    local lines
    lines=($(${programName} __complete --shell bash -- "\${COMP_WORDS[@]:1:COMP_CWORD}" 2>/dev/null))

    local count=\${#lines[@]}
    if (( count == 0 )); then
        return 0
    fi

    local last="\${lines[count-1]}"
    local directive=0
    if [[ "$last" == :* ]]; then
        directive="\${last:1}"
        unset 'lines[count-1]'
    fi

    local cur="\${COMP_WORDS[COMP_CWORD]}"

    # 16 = FileCompletion, 32 = DirectoryCompletion
    if (( directive & 16 )); then
        COMPREPLY=($(compgen -f -- "$cur"))
    elif (( directive & 32 )); then
        COMPREPLY=($(compgen -d -- "$cur"))
    elif (( \${#lines[@]} > 0 )); then
        COMPREPLY=("\${lines[@]}")
    fi

    return 0
}

# Register the completion function
complete -o default -F _${programName}_completions ${programName}
`,
    shell: "bash",
    installInstructions: `# To enable completions, add the following to your ~/.bashrc:

# Option 1: Source directly
eval "$(${programName} completion bash)"

# Option 2: Save to a file
${programName} completion bash > ~/.local/share/bash-completion/completions/${programName}

# Then reload your shell or run:
source ~/.bashrc`,
  };
}
