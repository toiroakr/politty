/**
 * Bash completion script generator (dynamic)
 */

import type { AnyCommand } from "../types.js";
import type { CompletionOptions, CompletionResult } from "./types.js";

/**
 * Generate bash completion script for a command
 *
 * Generates a minimal script that delegates all logic to the CLI's __complete command.
 * The shell script only handles:
 * - Getting current command line tokens
 * - Calling __complete with --shell bash
 * - Setting COMPREPLY from the output
 * - Falling back to native file/directory completion when directed
 */
export function generateBashCompletion(
  _command: AnyCommand,
  options: CompletionOptions,
): CompletionResult {
  const programName = options.programName;

  return {
    script: `# Bash completion for ${programName}
# Generated by politty

_${programName}_completions() {
    local IFS=$'\\n'
    local lines
    set -f
    lines=($(${programName} __complete --shell bash -- "\${COMP_WORDS[@]:1:COMP_CWORD}" 2>/dev/null))
    set +f

    local count=\${#lines[@]}
    if (( count == 0 )); then
        return 0
    fi

    local last="\${lines[count-1]}"
    local directive=0
    if [[ "$last" == :* ]]; then
        directive="\${last:1}"
        unset 'lines[count-1]'
        (( count-- ))
    fi

    # Parse @ext: metadata (extension filter for native file completion)
    local extensions=""
    if (( count > 0 )); then
        local maybe_ext="\${lines[count-1]}"
        if [[ "$maybe_ext" == @ext:* ]]; then
            extensions="\${maybe_ext:5}"
            unset 'lines[count-1]'
        fi
    fi

    local cur="\${COMP_WORDS[COMP_CWORD]}"

    # Strip --opt= prefix for native file/directory completion
    local inline_prefix=""
    if [[ "$cur" == --*=* ]]; then
        inline_prefix="\${cur%%=*}="
        cur="\${cur#*=}"
    fi

    # 16 = FileCompletion: delegate entirely to native file completion
    if (( directive & 16 )); then
        local -a entries=($(compgen -f -- "$cur"))
        if [[ -n "$inline_prefix" ]]; then
            local i
            for (( i=0; i<\${#entries[@]}; i++ )); do
                entries[$i]="\${inline_prefix}\${entries[$i]}"
            done
        fi
        COMPREPLY=("\${entries[@]}")
        compopt -o filenames
        return 0
    fi

    # Extension-filtered file completion: keep matching files + directories
    if [[ -n "$extensions" ]]; then
        local -a all_entries=($(compgen -f -- "$cur"))
        local IFS=','
        local -a ext_arr=($extensions)
        IFS=$'\\n'
        for f in "\${all_entries[@]}"; do
            if [[ -d "$f" ]]; then
                COMPREPLY+=("\${inline_prefix}$f")
            else
                for ext in "\${ext_arr[@]}"; do
                    if [[ "$f" == *".$ext" ]]; then
                        COMPREPLY+=("\${inline_prefix}$f")
                        break
                    fi
                done
            fi
        done
        compopt -o filenames
        compopt +o default 2>/dev/null
        return 0
    fi

    # Start with JS candidates
    if (( \${#lines[@]} > 0 )); then
        COMPREPLY=("\${lines[@]}")
    fi

    # 32 = DirectoryCompletion: merge native directory matches
    if (( directive & 32 )); then
        local -a dirs=($(compgen -d -- "$cur"))
        if [[ -n "$inline_prefix" ]]; then
            local i
            for (( i=0; i<\${#dirs[@]}; i++ )); do
                dirs[$i]="\${inline_prefix}\${dirs[$i]}"
            done
        fi
        COMPREPLY+=("\${dirs[@]}")
        compopt -o filenames
    fi

    # 2 = NoFileCompletion, 32 = DirectoryCompletion:
    # suppress -o default file fallback when completions are restricted
    if (( directive & 2 )) || (( directive & 32 )); then
        compopt +o default 2>/dev/null
    fi

    return 0
}

# Register the completion function
complete -o default -F _${programName}_completions ${programName}
`,
    shell: "bash",
    installInstructions: `# To enable completions, add the following to your ~/.bashrc:

# Option 1: Source directly
eval "$(${programName} completion bash)"

# Option 2: Save to a file
${programName} completion bash > ~/.local/share/bash-completion/completions/${programName}

# Then reload your shell or run:
source ~/.bashrc`,
  };
}
