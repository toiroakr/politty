/**
 * Bash completion script generator
 */

import type { AnyCommand } from "../types.js";
import { extractCompletionData } from "./extractor.js";
import type {
  CompletableOption,
  CompletableSubcommand,
  CompletionOptions,
  CompletionResult,
} from "./types.js";

/**
 * Generate option completions for bash
 */
function generateOptionCompletions(options: CompletableOption[]): string[] {
  const completions: string[] = [];

  for (const opt of options) {
    completions.push(`--${opt.cliName}`);
    if (opt.alias) {
      completions.push(`-${opt.alias}`);
    }
  }

  return completions;
}

/**
 * Generate subcommand completions for bash
 */
function generateSubcommandCompletions(subcommands: CompletableSubcommand[]): string[] {
  return subcommands.map((sub) => sub.name);
}

/**
 * Generate the bash completion script
 */
function generateBashScript(
  command: CompletableSubcommand,
  programName: string,
  includeDescriptions: boolean,
): string {
  const allOptions = collectAllOptions(command);

  const optionList = generateOptionCompletions(allOptions).join(" ");
  const subcommandList = generateSubcommandCompletions(command.subcommands).join(" ");

  // Build subcommand-specific completions
  const subcommandCases = buildSubcommandCases(command.subcommands, includeDescriptions);

  return `# Bash completion for ${programName}
# Generated by politty

_${programName}_completions() {
    local cur prev words cword
    _init_completion || return

    local commands="${subcommandList}"
    local global_opts="${optionList}"

    # Handle subcommand-specific completions
    local cmd_index=1
    local cmd=""

    # Find the subcommand
    for ((i=1; i < cword; i++)); do
        case "\${words[i]}" in
            -*)
                # Skip options and their values
                if [[ "\${words[i]}" == *=* ]]; then
                    continue
                fi
                # Check if next word is the option's value
                local opt="\${words[i]}"
                case "$opt" in
                    ${
                      allOptions
                        .filter((o) => o.takesValue)
                        .map((o) => `--${o.cliName}|-${o.alias || ""}`)
                        .join("|") || "--*"
                    }
                        ((i++))
                        ;;
                esac
                ;;
            *)
                # Found a subcommand
                cmd="\${words[i]}"
                cmd_index=$i
                break
                ;;
        esac
    done

    # Subcommand-specific completions
    case "$cmd" in
${subcommandCases}
        *)
            # Root level completions
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "$global_opts" -- "$cur"))
            else
                COMPREPLY=($(compgen -W "$commands" -- "$cur"))
            fi
            ;;
    esac

    return 0
}

# Register the completion function
complete -F _${programName}_completions ${programName}
`;
}

/**
 * Build case statements for subcommand-specific completions
 */
function buildSubcommandCases(
  subcommands: CompletableSubcommand[],
  includeDescriptions: boolean,
): string {
  if (subcommands.length === 0) {
    return "";
  }

  let cases = "";

  for (const sub of subcommands) {
    const options = generateOptionCompletions(sub.options).join(" ");
    const nestedSubcommands = generateSubcommandCompletions(sub.subcommands).join(" ");
    const completions = [options, nestedSubcommands].filter(Boolean).join(" ");

    cases += `        ${sub.name})\n`;
    cases += `            COMPREPLY=($(compgen -W "${completions}" -- "$cur"))\n`;
    cases += `            ;;\n`;

    // Add nested subcommand cases if any
    if (sub.subcommands.length > 0) {
      const nestedCases = buildSubcommandCases(sub.subcommands, includeDescriptions);
      if (nestedCases) {
        cases += nestedCases;
      }
    }
  }

  return cases;
}

/**
 * Collect all options from a command tree
 */
function collectAllOptions(command: CompletableSubcommand): CompletableOption[] {
  const options = [...command.options];

  for (const sub of command.subcommands) {
    options.push(...collectAllOptions(sub));
  }

  // Deduplicate by name
  const seen = new Set<string>();
  return options.filter((opt) => {
    if (seen.has(opt.name)) {
      return false;
    }
    seen.add(opt.name);
    return true;
  });
}

/**
 * Generate bash completion script for a command
 */
export function generateBashCompletion(
  command: AnyCommand,
  options: CompletionOptions,
): CompletionResult {
  const data = extractCompletionData(command, options.programName);
  const includeDescriptions = options.includeDescriptions ?? true;

  const script = generateBashScript(data.command, options.programName, includeDescriptions);

  return {
    script,
    shell: "bash",
    installInstructions: `# To enable completions, add the following to your ~/.bashrc:

# Option 1: Source directly
eval "$(${options.programName} completion bash)"

# Option 2: Save to a file
${options.programName} completion bash > ~/.local/share/bash-completion/completions/${options.programName}

# Then reload your shell or run:
source ~/.bashrc`,
  };
}
