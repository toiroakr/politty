/**
 * Bash completion script generator (dynamic)
 */

import type { AnyCommand } from "../types.js";
import type { CompletionOptions, CompletionResult } from "./types.js";

/**
 * Generate bash completion script for a command
 *
 * Generates a dynamic script that calls the CLI's __complete command at runtime.
 */
export function generateBashCompletion(
  _command: AnyCommand,
  options: CompletionOptions,
): CompletionResult {
  const programName = options.programName;

  return {
    script: `# Bash completion for ${programName}
# Generated by politty

_${programName}_completions() {
    local cur="\${COMP_WORDS[COMP_CWORD]}"
    local args=("\${COMP_WORDS[@]:1:COMP_CWORD}")
    local completion_prefix=""
    local completion_cur="$cur"

    # Handle inline option-value completion for long options (e.g. --format=js)
    if [[ "$cur" == --*=* ]]; then
        completion_prefix="\${cur%%=*}="
        completion_cur="\${cur#*=}"
    fi

    # Call the CLI to get completions
    local output
    if ! output=$(${programName} __complete -- "\${args[@]}" 2>/dev/null); then
        # Backward compatibility for CLIs exposing only completion
        output=$(${programName} completion __complete -- "\${args[@]}" 2>/dev/null)
    fi

    local candidates=()
    local directive=0
    local command_completion=""
    local file_extensions=""

    # Parse output: value\\tdescription lines, ending with :directive
    while IFS=$'\\t' read -r name desc; do
        if [[ "$name" == :* ]]; then
            directive="\${name:1}"
        elif [[ "$name" == __command:* ]]; then
            command_completion="\${name#__command:}"
        elif [[ "$name" == __extensions:* ]]; then
            file_extensions="\${name#__extensions:}"
        elif [[ -n "$name" ]]; then
            candidates+=("$name")
        fi
    done <<< "$output"

    # Execute shellCommand completion if requested by __complete
    if [[ -n "$command_completion" ]]; then
        while IFS= read -r command_candidate; do
            if [[ -n "$command_candidate" ]]; then
                candidates+=("$command_candidate")
            fi
        done < <(eval "$command_completion" 2>/dev/null)
    fi

    # Handle directives
    # 16 = FileCompletion, 32 = DirectoryCompletion
    if (( directive & 16 )); then
        COMPREPLY=($(compgen -f -- "$completion_cur"))

        if [[ -n "$file_extensions" ]]; then
            local -a filtered=()
            local -a extension_list=()
            local file_candidate ext

            IFS=',' read -r -a extension_list <<< "$file_extensions"

            for file_candidate in "\${COMPREPLY[@]}"; do
                if [[ -d "$file_candidate" ]]; then
                    filtered+=("$file_candidate")
                    continue
                fi

                for ext in "\${extension_list[@]}"; do
                    if [[ "$file_candidate" == *."$ext" ]]; then
                        filtered+=("$file_candidate")
                        break
                    fi
                done
            done

            COMPREPLY=("\${filtered[@]}")
        fi
    elif (( directive & 32 )); then
        COMPREPLY=($(compgen -d -- "$completion_cur"))
    elif [[ \${#candidates[@]} -gt 0 ]]; then
        COMPREPLY=($(compgen -W "\${candidates[*]}" -- "$completion_cur"))
    fi

    if [[ -n "$completion_prefix" && \${#COMPREPLY[@]} -gt 0 ]]; then
        local -a prefixed=()
        local candidate
        for candidate in "\${COMPREPLY[@]}"; do
            prefixed+=("$completion_prefix$candidate")
        done
        COMPREPLY=("\${prefixed[@]}")
    fi

    return 0
}

# Register the completion function
complete -F _${programName}_completions ${programName}
`,
    shell: "bash",
    installInstructions: `# To enable completions, add the following to your ~/.bashrc:

# Option 1: Source directly
eval "$(${programName} completion bash)"

# Option 2: Save to a file
${programName} completion bash > ~/.local/share/bash-completion/completions/${programName}

# Then reload your shell or run:
source ~/.bashrc`,
  };
}
