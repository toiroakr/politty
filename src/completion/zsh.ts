/**
 * Zsh completion script generator
 */

import type { AnyCommand } from "../types.js";
import { extractCompletionData } from "./extractor.js";
import type {
  CompletableOption,
  CompletableSubcommand,
  CompletionOptions,
  CompletionResult,
} from "./types.js";

/**
 * Escape a string for use in zsh completion descriptions
 */
function escapeForZsh(str: string): string {
  return str.replace(/'/g, "''").replace(/\[/g, "\\[").replace(/\]/g, "\\]");
}

/**
 * Generate option specs for zsh _arguments
 */
function generateOptionSpecs(options: CompletableOption[], includeDescriptions: boolean): string[] {
  const specs: string[] = [];

  for (const opt of options) {
    const desc = includeDescriptions && opt.description ? escapeForZsh(opt.description) : "";
    const valueSpec = opt.takesValue ? ":" : "";

    // Long option
    if (desc) {
      specs.push(`'--${opt.cliName}[${desc}]${valueSpec}'`);
    } else {
      specs.push(`'--${opt.cliName}${valueSpec}'`);
    }

    // Short option (alias)
    if (opt.alias) {
      if (desc) {
        specs.push(`'-${opt.alias}[${desc}]${valueSpec}'`);
      } else {
        specs.push(`'-${opt.alias}${valueSpec}'`);
      }
    }
  }

  return specs;
}

/**
 * Generate subcommand descriptions for zsh
 */
function generateSubcommandDescriptions(
  subcommands: CompletableSubcommand[],
  includeDescriptions: boolean,
): string {
  if (subcommands.length === 0) {
    return "";
  }

  const lines = subcommands.map((sub) => {
    const desc = includeDescriptions && sub.description ? escapeForZsh(sub.description) : sub.name;
    return `'${sub.name}:${desc}'`;
  });

  return lines.join("\n            ");
}

/**
 * Generate a zsh function for a subcommand
 */
function generateSubcommandFunction(
  command: CompletableSubcommand,
  programName: string,
  includeDescriptions: boolean,
  parentPath: string[] = [],
): string {
  const currentPath = [...parentPath, command.name];
  const funcName =
    parentPath.length === 0
      ? `_${programName}`
      : `_${programName}_${currentPath.slice(1).join("_")}`;

  const optionSpecs = generateOptionSpecs(command.options, includeDescriptions);
  const hasSubcommands = command.subcommands.length > 0;

  let func = `${funcName}() {\n`;
  func += `    local -a args\n`;

  if (hasSubcommands) {
    const subcommandDesc = generateSubcommandDescriptions(command.subcommands, includeDescriptions);
    func += `    local -a subcommands\n`;
    func += `    subcommands=(\n`;
    func += `            ${subcommandDesc}\n`;
    func += `    )\n\n`;
  }

  func += `    args=(\n`;

  if (hasSubcommands) {
    func += `        '1:command:->command'\n`;
    func += `        '*::arg:->args'\n`;
  }

  for (const spec of optionSpecs) {
    func += `        ${spec}\n`;
  }

  func += `    )\n\n`;

  func += `    _arguments -s -S $args\n\n`;

  if (hasSubcommands) {
    func += `    case "$state" in\n`;
    func += `        command)\n`;
    func += `            _describe -t commands 'command' subcommands\n`;
    func += `            ;;\n`;
    func += `        args)\n`;
    func += `            case $words[1] in\n`;

    for (const sub of command.subcommands) {
      const subFuncName = `_${programName}_${[...currentPath.slice(1), sub.name].join("_")}`;
      func += `                ${sub.name})\n`;
      func += `                    ${subFuncName}\n`;
      func += `                    ;;\n`;
    }

    func += `            esac\n`;
    func += `            ;;\n`;
    func += `    esac\n`;
  }

  func += `}\n`;

  return func;
}

/**
 * Collect all subcommand functions recursively
 */
function collectSubcommandFunctions(
  command: CompletableSubcommand,
  programName: string,
  includeDescriptions: boolean,
  parentPath: string[] = [],
): string[] {
  const functions: string[] = [];

  // Generate function for this command
  functions.push(generateSubcommandFunction(command, programName, includeDescriptions, parentPath));

  // Generate functions for subcommands
  const currentPath = parentPath.length === 0 ? [command.name] : [...parentPath, command.name];

  for (const sub of command.subcommands) {
    functions.push(
      ...collectSubcommandFunctions(sub, programName, includeDescriptions, currentPath),
    );
  }

  return functions;
}

/**
 * Generate the zsh completion script
 */
function generateZshScript(
  command: CompletableSubcommand,
  programName: string,
  includeDescriptions: boolean,
): string {
  const functions = collectSubcommandFunctions(command, programName, includeDescriptions);

  return `#compdef ${programName}

# Zsh completion for ${programName}
# Generated by politty

${functions.join("\n")}

_${programName} "$@"
`;
}

/**
 * Generate zsh completion script for a command
 */
export function generateZshCompletion(
  command: AnyCommand,
  options: CompletionOptions,
): CompletionResult {
  const data = extractCompletionData(command, options.programName);
  const includeDescriptions = options.includeDescriptions ?? true;

  const script = generateZshScript(data.command, options.programName, includeDescriptions);

  return {
    script,
    shell: "zsh",
    installInstructions: `# To enable completions, add the following to your ~/.zshrc:

# Option 1: Source directly (add before compinit)
eval "$(${options.programName} completion zsh)"

# Option 2: Save to a file in your fpath
${options.programName} completion zsh > ~/.zsh/completions/_${options.programName}

# Make sure your fpath includes the completions directory:
# fpath=(~/.zsh/completions $fpath)
# autoload -Uz compinit && compinit

# Then reload your shell or run:
source ~/.zshrc`,
  };
}
